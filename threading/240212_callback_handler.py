# Напишите функцию callback_handler, которая запускает целевую задачу (например, выполнение запроса), 
# а в случае получения результата за заданное время запускает дополнительную задачу (например, сохранение результата запроса).

# Напишите функцию, которая выполняет целевую задачу task и задачу дополнительной обработки callback_task в отдельных потоках.
# При этом известно, что признаком успешного выполнения целевой задачи является переменная result, которая в случае успеха
# принимает значение True (False - значение по умолчанию). Булевская переменная result доступна в глобальной области видимости.

# Целевая функция task  принимает аргументы args в виде кортежа значений, поэтому при создании потока достаточно указать
# threading.Thread(target=task, args=args, ....). Функция callback_task  работает без аргументов и она выполняется не мгновенно,
# сохранение результатов занимает небольшое время!

# Для ограничения ожидания успешного выполнения целевой задачи ограничьте время работы потока целевой задачи 0.3 секундой
# (считаем, что за 300 мс. (или раньше) запрос точно будет успешно получен, если нет - дальнейшие ожидания нужно прекратить). 
# Если result True, потоком - таймером выполняем дополнительную задачу и дожидаемся ее завершения, если нет - не выполняем 
# (результат не получен, нечего сохранять).

# Решите задачу без расчета времени выполнения, используйте поток, поток-таймер и методы join, start, cancel. 
# Во временных уставках допускается погрешность в 0.05 секунды.



from threading import Timer, Thread
from typing import Callable


def callback_handler(task: Callable = None, args=(), callback_task: Callable = None) -> None:
    global result

    request_thread = Thread(target=task, args=args, daemon=True)
    data_thread = Timer(interval=0.305, function=callback_task)
    
    request_thread.start()
    data_thread.start()

    request_thread.join(0.3)

    if not result:
        data_thread.cancel()
    data_thread.join()