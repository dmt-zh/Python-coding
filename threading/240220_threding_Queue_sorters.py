# В тестирующей системе определена функция - генератор get_obj(). Генератор возвращает элементы.
# Признак определяется функцией is_prim(). Функция возвращает True или False. 
# функция генератор get_obj() и функция is_prim() могут ненадолго "подвисать". Генератор не мгновенно возвращает очередной элемент,
# а функция проверки не мгновенно возвращает результат. Но гарантируется, что генератор возвращает каждый элемент с задержкой,
# не превышающей 100 мс., а в случае серьезных проблем генератор возвращает значение None. После этого запрашивать следующее значение
# у генератора не нужно, это может привести к сбоям, ошибкам или зависанию.

# Ваша задача осталась прежней: создать и заполнить две очереди, только сделать это нужно двумя потоками для улучшения производительности
# и отзывчивости. Поэтому создайте два дочерних потока - сортировщика, каждый будет складывать в обе очереди в зависимости от результата
# работы функции is_prim().

# Тестирующая система проверит общее время выполнения программы, содержимое обеих очередей prim_queue, sub_queue.

# Подумайте как организовать передачу объектов из функции генератора в два потока - сортировщика. 
# Как остановить работу дочерних потоков и всей программы в случае получения значения None, но в то же время все-таки дождаться
# выполнения функции is_prim() для предыдущего (до None) значения, полученного от генератора.


from queue import Queue, Empty
from threading import Thread

prim_queue = Queue()
sub_queue = Queue()
tmp_queue = Queue()

def task():
    while True:
        try:
            obj = tmp_queue.get(timeout=0.1)
            if is_prim(obj):
                prim_queue.put(obj)
            else:
                sub_queue.put(obj)
        except Empty:
            break


def main():
    for obj in get_obj():
        if obj is None:
            break
        tmp_queue.put(obj)

            
t1 = Thread(target=task, daemon=True)
t2 = Thread(target=task, daemon=True)
t1.start()
t2.start()

main_thr = Thread(target=main)
main_thr.start()
main_thr.join()

t1.join()
t2.join()