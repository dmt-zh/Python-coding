# Ваша задача написать программу поиска слова в строке. Задача усложняется тем, что слово должно 
# определяться в разных его формах. Например, слово: программирование

# может иметь следующие формы: программирование, программированию, программированием, программировании,
#  программирования, программированиям, программированиями, программированиях

# Для решения этой задачи необходимо объявить класс Morph (морфология), объекты которого создаются 
# командой: mw = Morph(word1, word2, ..., wordN)
# где word1, word2, ..., wordN - возможные формы слова.

# В классе Morph реализовать методы:
# add_word(self, word) - добавление нового слова (если его нет в списке слов объекта класса Morph);
# get_words(self) - получение кортежа форм слов.

# Также с объектами класса Morph должны выполняться следующие операторы сравнения:
# mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
# mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)

# И аналогичная пара сравнений:
# "word" == mw1
# "word" != mw1

# После создания класса Morph, формируется список dict_words из объектов этого класса, для следующих 
# слов с их словоформами:

# - связь, связи, связью, связей, связям, связями, связях
# - формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
# - вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
# - эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
# - день, дня, дню, днем, дне, дни, дням, днями, днях

# Затем, прочитайте строку из входного потока командой:

# text = input()
# Найдите все вхождения слов из списка dict_words (используя операторы сравнения) в строке text 
# (без учета регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.

# Sample Input:
# Мы будем устанавливать связь завтра днем.

# Sample Output:
# 2



from itertools import product

class Morph:
    def __init__(self, *args):
        self.__words = list(map(lambda w: w.strip(" .,!?;:").lower(), args))

    @classmethod
    def __is_valid(cls, obj):
        return type(obj) == str

    def add_word(self, word):
        if self.__is_valid(word):
            w = word.strip(" .,!?;:").lower()
            if not w in set(self.__words):
                self.__words.append(word)
        else:
            raise ValueError(f'Invalid type {type(word)}. Only strings can be added.')

    def get_words(self):
        return tuple(self.__words)

    def __eq__(self, word):
        if not self.__is_valid(word):
            return ValueError('Operand has to be of the type "string".')
        return word.lower() in set(self.__words)

    def __req__(self, word):
        return word.lower() in set(self.__words)
    

w1 = Morph('связь', 'связи', 'связью', 'связи', 'связей', 'связям', 'связями', 'связях')
w2 = Morph('формула', 'формулы', 'формуле', 'формулу', 'формулой', 'формул', 'формулам', 'формулами','формулах')
w3 = Morph('вектор', 'вектора', 'вектору', 'вектором', 'векторе', 'векторы', 'векторов', 'векторам', 'векторами', 'векторах')
w4 = Morph('эффект', 'эффекта', 'эффекту', 'эффектом', 'эффекте', 'эффекты', 'эффектов', 'эффектам', 'эффектами', 'эффектах')
w5 = Morph('день', 'дня', 'дню', 'днем', 'дне', 'дни', 'дням', 'днями', 'днях')
dict_words = [w1, w2, w3, w4, w5]


text = input()   # эту строчку не менять
lst = list(map(lambda x: x.strip('.,:;!?'), text.split()))
print(sum((w == dw for w, dw in product(lst, dict_words))))