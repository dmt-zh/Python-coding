# Напишите функцию для параллельной обработки задач parallel_handler. Она принимает задачи, аргументы для этих задач,
# создает дочерние процессы для параллельного выполнения нескольких задач. Для выполнения каждой отдельной задачи создается отдельный процесс.
# У нее три аргумента:
# ​1 - ​​​​​​список или кортеж вызываемых объектов - задач,
# 2 - список или кортеж из аргументов для каждой задачи (каждая задача может иметь несколько аргументов!). Для решения достаточно предусмотреть
#     только передачу позиционных аргументов,
# 3 - не обязательный аргумент - timeout, уставка максимального времени ожидания завершения всех задач. Если аргумент не задан - время ожидания
#     не ограничено. Если аргумент задан (int, количество секунд), то выполняется контроль длительности выполнения задач. Если за отведенное 
#     время задачи не успевают завершиться, процесс, который выполняет такую длительную задачу, должен быть завершен принудительно.

# Тестирующая система вызовет эту функцию с различным набором задач и проверит время решения. Синтаксис вызова функции будет следующим:

# if __name__ == "__main__":
#     parallel_handler((task1, task2, task3, task4),
#                      ((1.5, 1), (1.6, 2), (3, "BFG", "DOOM"), (4, 4, 4.01, 0.9)), timeout=2)

# Гарантируется, что список задач и список аргументов для задач будут соответствовать.

# Напишите решение без применения sleep. Ваша функция может использовать другие функции, если это необходимо.




from multiprocessing import Process
from threading import Thread


def parallel_handler(*args, timeout=None):

    def task_runner(tasks_group, attrs_group):
        processes = [Process(target=task, args=attrs, daemon=True) for task, attrs in zip(tasks_group, attrs_group)]
        for pr in processes:
            pr.start()

        for pr in processes:
            pr.join()

    minor_thread = Thread(target=task_runner, args=(args[0], args[1]), daemon=True)
    minor_thread.start()
    minor_thread.join(timeout=timeout)