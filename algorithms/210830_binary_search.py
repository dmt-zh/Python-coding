# Алгоритм бинарного поиска. Производит поиск искомого элемента в отсортированном массиве за время О(log n).

# Генерируем отсортированный массив из чисел
lst = [i for i in range(1, 1000001)]

# Произвольно выбираем элемент для поиска
num = int(input('Enter a number, and I guess it! ').strip())

# Определяем функцию для поиска элемента по заданному массиву
def binary_search(lst, item):
    cnt = 0                                                   # задаем счетчик шагов алгоритма
    start = 0                                                 # начальный интервал поиска в массиве
    stop = len(lst) - 1                                       # конечный интервал поиска в массиве

    while start <= stop:                                      # пока эта часть не сократится до одного эnемента
        cnt += 1                                              # увеличивем счетчик шагов
        mid = int((start + stop)/2)                           # делим массив на половину
        if lst[mid] == item:                                  # проверяем средний эnемент
            return f'Your number is {item}. ' \
                   f'It\'s taken only {cnt} steps. ' \
                   f'Total list has {len(lst):,} numbers.'    # если совподает, возвращаем элемент и количество шагов алгоритма
        if lst[mid] > item:                                   # если элемент находится в нижней половине массива
            stop = mid - 1                                    # отбрасываем верхнюю половину массива
        else:
            start = mid + 1                                   # иначе отбрасываем нижнюю половину массива
    return None                                               # если значение не найдено

print(binary_search(lst, num))
