# Проверка свойства дерева поиска
# Проверить, является ли данное двоичное дерево деревом поиска.

# Вы тестируете реализацию двоичного дерева поиска. У вас уже написан код, который ищет, добавляет и удаляет ключи,
# а также выводит внутреннее состояние структуры данных после каждой операции. Вам осталось проверить, что в каждый
# момент дерево остаётся корректным деревом поиска. Другими словами, вы хотите проверить, что для дерева корректно
# работает поиск, если ключ есть в дереве, то процедура поиска его обязательно найдёт, если ключа нет — то не найдёт.

# Формат входа. Первая строка содержит число вершин n. Вершины дерева пронумерованы числами от 0 до n − 1. Вершина 0
# является корнем. Каждая из следующих n строк содержит информацию о вершинах 0 , 1 , . . . , n − 1: i-я строка задаёт
# числа key_i, left_i и right_i, где key_i — ключ вершины i, left_i — индекс левого сына вершины i, а right_i — индекс
# правого сына вершины i. Если у вершины i нет одного или обоих сыновей, соответствующее значение равно −1.
# Формат выхода. Выведите «CORRECT», если дерево является корректным деревом поиска, и «INCORRECT» в противном случае.

# Sample Input:
# 3
# 2 1 2
# 1 -1 -1
# 3 -1 -1

# Sample Output:
# CORRECT



import sys
sys.setrecursionlimit(100000)

read = sys.stdin
size = int(read.readline())

tree = [tuple(map(int, read.readline().split())) for _ in range(size)]
values = []

def in_order(root):
    if tree[root][1] > -1:
        in_order(tree[root][1])
    values.append(tree[root][0])
    if tree[root][2] > -1:
        in_order(tree[root][2])

if size == 0:
    print('CORRECT')
else:
    in_order(0)
    print('CORRECT' if values == sorted(values) else 'INCORRECT')